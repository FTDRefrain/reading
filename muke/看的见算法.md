1. UI构建

   1. 抗锯齿，因为有像素点在，所以矩形会有变，抗锯齿的原理就是把多出的部分，利用颜色渐变，从白渐变到黑
   2. 双缓存技术：因为画布画完后投影到屏幕上，之后图形改变的时候，是先清空再画上去，所以屏幕会有闪烁；双缓存就是说再多一张画布，然后交替计算图形位置和投影到屏幕，这样就没有空白的过程

2. 随机模拟问题

   1. 100个人，每人100元，每次都随机给其他人1元，足够长时间后的状态是？利用计算机随机模拟可以看出状态是不固定的，不是大家趋于平均，实际上相当于1万元随机分给100个人然后挑一个状态出来
   2. 蒙特卡洛算法：二战时候解决随机模拟问题提出的算法代号是蒙特卡洛，因为本身是赌城，模拟方式和赌博差不多，也有拉斯维加斯算法
   3. 核心就是大量随机样本得到某一个系统计算的值；
   4. 三门问题：共有三扇门，一扇门后面有车，主持人打开一扇门且后面没有车，用户换门还是不换？
      1. 随机模拟过程，即模拟换门和不换门两个事件
      2. 猜对判断：随机有奖，随机用户猜，两个相同的时候换门就输，不同时候换门赢
      3. 结合上面的两个事件，完成模拟
      4. 问题在于主持人的选择不是等概率的
   5. 会不会中奖，即20%中奖，5个会不会？
      1. 显然不会，模拟的过程是多次的抽5次，记录每一个样本的true和false；
      2. 这个5是期望值，对于个人来讲是没有用的

3. 排序问题

   1. 选择排序，依次找最小值然后放到头部
      1. 可视化方面：已经排好的一个颜色，当前扫描的一个颜色，未扫描的一个颜色，当前循环中最小的一个颜色
      2. 三个变量，已经排好的索引，正在比较的索引，当前最小值的索引
      3. 变量一旦改变就setColor完成可视化
      4. 比较次数多但是交换次数少，如果是集装箱移动的话或者移动耗时，肯定还是选择排序最好
   2. 插入元素，从头到尾依次拿到新的元素和前面进行比较然后移动
      1. 因为每次交换都是借助了中间变量，所以可以先用变量接住i，然后每次比较都是原来的元素向后移动，直到找到i的位置
      2. 对于近乎有序的数组，本身可以是O(n)的算法
      3. 向前移动的过程中，二分查找不一定好，因为查到了还是要移动，不减少复杂度，而且对于近乎有序的数组反而麻烦
   3. 归并排序
      1. branch and conquer的思想要记住，递归的方法不要细想，但是记住方法的意义和输入输出
      2. 想看结构就多一个参数记录depth，然后打印的时候根据depth设置空格位数
      3. 优化方式：数据小的时候使用插入，左边已经比右边小的时候直接合并就好了
      4. merge的时候采用的是外排的策略
      5. 正常递归的方式是自顶向下的，也可以改成自下向上的
   4. 快速排序
      1. Partition然后左右都是递归执行，找到一个数，然后左边都是小于的右边都是大于的
      2. 大量元素都相同时候效率很差，对于单路来讲
      3. 双路解决了上面的问题，因为可以停在接近中间的位置
      4. 三路，即多一个和目标相等的区间，这样只要排小于和大于的区间，对于大量相同效果好
   5. 堆排
      1. 构建最大堆，将最后和头交换后再构建最大堆，递归完成

4. 迷宫求解问题

   1. 图的遍历，两个节点之间路程的问题，即上下左右四个递归过程，当坐标是出口则return true，当没有走过或者不是墙壁的时候则走，如果true就直接返回
   2. 加颜色就是每次go的时候设置true，然后for循环结束设置成false，表示遍历后也还是没有解，在最后return false表示没有解
   3. 借助栈实现非递归，
      1. 一个问题就是路径。因为之前是递归，所以for结束后是整个路径的结束，现在的for结束实际上是当前节点的四个方向结束，并不是路径的结束。
      2. 解决方案是，每次遍历节点的时候记录上一个点的位置，之后根据终点往上遍历就好
      3. 找到一条但不一定最短
   4. 广度优先是使用队列实现，对于无权图找到的是最短路径
   5. 可以看出，3和4的实现逻辑一样，所以可以将栈和队列都看看成是抽象队列，只是进和出的方式不同

5. 迷宫生成算法

   1. 单路径随机迷宫本质是一颗树，因为找到任意两点有路径的总和是树，所以问题在于生成一个随机树，和利用图生成最小生成树有些不同
   2. 生成算法：首先最外层找到两个点作为出入口，中间包围部分看成黑白相间的方块，目的是去掉若干个黑块使得出入口有一条路连接
   3. 解决方法：使用随机出队队列，白块遍历的时候，出队时候是随机的而不是从头出去，出去的过程就是随机找一个然后将最后一个和目标位置互换，然后出去最后一个
   4. 解开迷雾过程，遍历到的点的四周打开，实现过程
   5. 问题在于DFS是向右向下然后S型完成迷宫生成，BFS则是向右后一起向下完成迷宫，所以就算随机选择出队也依旧是向右向下的趋势；提出每次入队和出队是随机从头和从尾进行选择，这样就结合了DFS和BFS
   6. 多路径，即带环就好，生成后随机选几个点链接到一起；边不占格子，即每个格子的四个边进行特定的去除；

6. 扫雷游戏

   1. 随机生成20个雷：将20个雷按照顺序排放在上面，然后大量的随机交换位置产生随机的结果。之前的排序测试用例也可以这么做
   2. 好的排序算法：等概率的产生所有的可能性
   3. 实验：统计大量样本下每个位置出现雷的概率，正常是等概率的
   4. Fisher-Yates-Knuth洗牌算法：随机选一个，和头部交换位置，然后剩下的里面再随机选一个，和剩下部分的头部交换位置，依次走下去；和之前的随机出队相似；
   5. 雷个数的计算：九宫格遍历方式是双层循环，先i-1到i+1，里面是j-1到j+1，这样9个就都有了；
   6. floodfill算法，找到指定边界的某一块区域，和前面的深度遍历一样

7. move the box

   1. 一般就是穷举所有的可能，使用的是回溯法

   2. 即走一步的结果，之后是走两步的结果，然后不断展开；找到一种方式是深度优先，找到有限步数内的结果就是广度

   3. 读取map，构建矩阵；不同的箱子对应不同的颜色，hash构建

   4. 箱子移动有左右下三种模式，因为上可以的话相当于上面的向下

   5. 回溯的结构伪代码如下

      ```javascript
      let stepDirec = [[-1, 0], [0, -1], [1, 0]]
      let vnode
      function solve(E, step){  
        for (let i = 0; i<N, i++){
          for(let j = 0; j<M;j++){
            if(map.check(i, j) != 'empty'){
              for (let m=0; m<3;m++){
                let newX = i + stepDirec[m][0]
                let newY = j + stepDirec[m][1]
      					// 交换位置
                swap(E, newE)
                // 更新后的方块处理
                run()
                if(solve(newE, step-1)){
                  return true
                }
              } 
            }
          }
        }
        return false
      }
      
      function run(){
        do{
          drop()
        } while(match())
      }
      ```

   6. drop的逻辑，双指针，一个表示自底向上遍历，另一个是有掉落则减1；一列一列的遍历

   7. match是匹配右边和下边的三个方块，颜色相同则标记，整体扫描完之后标记的都去掉，这里就涵盖了多余3个的时候大家一起消掉

   8. 输出结果还是采用记录步骤然后递归输出结果

   9. 重叠子问题，即不同步骤产生的结果相同，使用查找表缓存起来；

8. 分形图的绘制

   1. 结构中存在自相似的部分，比如中树结构中分支可以看成新树
   2. 先找到最外层的结构，然后depth增长看里面能不能也分成小结构；比如，3X3黑白格，depth加深一层就是一个小单元格看成3X3的结构，然后再次细化下去；
   3. 找规律的时候从最简的单元开始走，不行再一次加上去