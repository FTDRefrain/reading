## 零散知识
1. html语义化，即使用带有特征的名字标签
2. css辨别，代码如下
  ```css
    /* 设置文字不可选取 */
  {
    -moz-user-select: none; /* 火狐 浏览器 */
    -webkit-user-select: none; /* Webkit 浏览器 */
    -o-user-select: none; /* Opera 浏览器 */
    -ms-user-select: none; /* IE10 浏览器 */
    -khtml-user-select: none; /* 早期浏览器 */
    user-select: none; /* 默认 */
  }
  ```
1. cookies、session、sessionStorage、localStorage
  1. cookie存内容最大是4k
  1. session存在服务器，本身占用服务器性能；
  2. sessionStroage在页面关闭时清空
  3. localStorage永久保存，只有用户清空才真的清
  4. 使用方式是getItem, setItem和removeItem
  5. 跨域：协议，域名，端口号三点
  6. cookie不能跨域访问，相同域名或者子域名下可以直接访问；利用这个特性，将自己所有的产品都放在同一个域名下，在一个域名登陆后，所有需要身份验证的东西都可以直接拿到cookie了，实现了**单点登录**
1. 盒模型：div的宽度可能被margin撑开，`box-sizing:border-box`设置；`box-sizing:content-box`则不包括外面的东西
2. 长度单位
  1. %用来表示百分比，推荐使用vw和vh来进行百分比确定；
  1. px，一般说的像素点
  2. em，相对于父元素的`font-size`
  3. rem，相对于根元素的`font-size`
  4. rpx，微信小程序的单位，1rpx = 屏幕宽度 / 750px；
1. render tree，CSS解析完成后，将和DOM TREE一起生成render tree；本身和DOM树元素对应而非一一对应，例如段落的换行生成的是不同的render，`display:none`会被无视;
2. 元素选择器：简单先不提，下面几个特殊的
  1. 伪类选择器：`a:hover`，
  2. 属性选择器：`input[type="text"]`
  3. 子元素选择器：`li:firth-child`, `p:nth-child(1)`
1. CSS新特性
  代码实例如下
  ```css
    div {
      width: 100px;
      height: 100px;
      border-radius: 50px;
      background: linear-gradient(red, orange);
      box-shadow: 10px 10px 5px #888888;
      position: relative;
      transition: width 2s;
      animation: mymove 5s infinite;
    }
    div:hover {
      width:300px;
      transform: rotate(7deg);
    }
    @keyframes mymove {
      from { left: 0px; }
      to { left: 200px; }
    }
  ```
1. BFC，块级上下文
  1. 特点：独立的渲染区域，处于内部的元素和外部的元素相互隔离，内外元素的定位不会相互影响；
  1. 优点：
    1. 防止margin元素重叠：
      1. 相邻元素的margin会有重叠的现象，同为正值且相交的时候(margin-top和margin-bottom)这类的，会取最大值而不是相加，一正一负没有影响；
      2. 父子元素的时候，子元素和父元素相交的地方，如(top和top)，会取最大的值，结果如下图
        ![图片](https://github.com/zuopf769/notebook/blob/master/fe/CSS%E5%A4%96%E8%BE%B9%E8%B7%9D(margin)%E9%87%8D%E5%8F%A0%E5%8F%8A%E9%98%B2%E6%AD%A2%E6%96%B9%E6%B3%95/4.jpg)
        子元素的margin替换父元素的margin，即这时候margin取决于子元素的最大margin；
      1. 解决方法：将ul变成`display:inline-block`；这样ul变成了BFC,因为是ul影响了div的margin，所以改ul而不是div
  2. 清除内部浮动：当ul浮动且div没有设置高度的时候，div会变成长条；这个时候就是改div了；
  1. float少用，尽量使用flex；reset会解决问题，可以减少BFC
1. 行内元素和块级元素
  1. 行内：`<span>`,`<i>`，`<a>`等，宽度和高度又内容决定
  2. 块级：默认宽度由父容器决定，默认高度由内容决定
  3. 使用`display:inline-block`可以改变；
1. flex布局
  1. 简单的一些小技巧如下
  ```css
    /* 设置 Flex 模式 */
    display: flex;

    /* 决定元素是横排还是竖着排，要不要倒序 */
    flex-direction: column;

    /* 决定元素换行格式，一行排不下的时候如何排 */
    flex-wrap: wrap;

    /* flex-flow = flex-direction + flex-wrap */
    flex-flow: column wrap;

    /* 同一排下对齐方式，空格如何隔开各个元素 */
    justify-content: space-between;

    /* 同一排下元素如何对齐，顶部对齐、中部对齐还是其他 */
    align-items: center;

    /* 多行对齐方式 */
    align-content: space-between;
  ```
  1. 实现水平或者垂直居中
    1. 水平
      1. 行内元素：`display: inline-block; text-align: center`
      1. 块级元素：`margin: 0 auto`;
      1. Flex：`display: flex; justify-content: center`;
    1. 垂直
      1. 行高 = 元素高：`line-height: height`
      1. Flex：`display: flex; align-items: center`;
    1. 水平垂直的话，flex就上把上面两个合在一起
  1. `flex-grow`使得下面的元素可以自适应或者进行等长度大小的划分；
1. JS原型链，目的是希望不同对象里面的相同方法占用相同的内存；
  首先看图，
  ![图片](https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-1-prototype.png)
  1. 大概的原理如下，
    1. 所有的开始是null
    2. `no1._proto_ = null`，且规定可以通过_proto_找到null
    3. 以no1为原型构建Object，`Object.prototype === no1`，
    4. `no2._proto_ = no1`，且规定所有都可以通过_proto_找到no2，Object也是这样，这样Object是所有对象的原型(Array, Number, Boolean, String)，即`a.prototype._proto_ = no2`; `a.prototype._proto_._proto_ = no1`
    5. 以no2为原型构建Function，`Function.prototype === no2`且`Function.prototype === Function._proto_`，即Function能找到自己；
  1. 应用部分
    实例代码如下
    ```javascript
      function Person(name) {
        this.name = name;
      }

      // 通过构造函数的 Person 的 prototype 属性找到 Person 的原型对象
      Person.prototype.eat = function() {
        console.log("吃饭");
      }
    ```
    通过Function.prototype找到了Object；
    另外，规定大写的方法是构造函数，小写的方法是普通函数，两者搭配即形成了类
  1. new方法的使用
    实际上是新建一个对象，且对象的原型链等于new的原型，即都指向no2，使用call将该对象的this指向到构造函数，然后每次声明`prototype.action`的时候，实际上对象也有了这个方法，然后调用的时候是调用对象的方法，该对象就是新建出来的实例，实例代码如下
    ```javascript
      // 1. 首先有个类型机器
      function ClassMachine() {
        console.log("类型创造机器");
      }
      // 2. 然后我们定义一个对象物品
      let thingOne = {};
      // 3. 对象物品通过万能术 __proto__ 指向了类型机器的原型（即 No 2 始机器）
      thingOne.__proto__ = ClassMachine.prototype;
      // 4. 将对象的this指向类型机器
      ClassMachine.call(thingOne);
      // 5. 定义了类型机器的动作
      ClassMachine.prototype.action = function(){
        console.log("动作创造机器");
      }
      // 6. 这个对象物品执行了动作
      thingOne.action();
    ```








