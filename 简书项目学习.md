1. index里面的`serviceWorker.unregister()`是启用PWA的方式，能进行缓存加速运行；另一种说法是opt-in
    1. 问题一：对于懒加载的东西，当server更新之后，本身不会更新，直到用户重新打开页面，reloading也不好使
    2. 使用的时候可以添加通知；例如上面的就可以告诉用户网页是缓存的且必要时候进行更新
    3. 仅支持https
    4. 生产环境下起作用，开发不好使(自然的，否则缓存改什么..)
    5. 本身只能在生产下测试，且浏览器要关匿名
    6. 不存跨域的东西
    7. 东西配置在`public/manifest.json`里面
1. 基础文件引入的时候，component是组件继承的东西，react则是用来是实现JSX；
2. 组件开头必须是大写
3. Fragment占位符，且不会作为div展示出来；
4. state里面数组的更改
    ```javascript
    this.setState({
        list:[...this.state.list,newValue]
    })
    ```
1. 删除实现，即map的时候，每一个添加一个click事件，同时传入index，之后使用slice(index,1)的方式删除特定位置的元素
2. 下面的方式表示内容要作为html进行解析  
    ```html
    <li dangerouslySetInnerHTML={{_html:this.yourHTML}} />
    ```
1. 使用label的方式进行点击区域或者目标区域的扩大，htmlFor进行id的绑定；
1. map这种组件渲染可以变成一个方法，这样render里面的结构很清晰且代码很少；
2. setState里面的赋值使用箭头函数的形式，且点击事件这种类似的东西要用变量接住值再进行赋值，因为是异步的过程；里面的箭头是一个回调函数，可传入prevState作为上一个状态；
3. 声明式开发：即整体构建好之后往里面放数据而不考虑更改结构的问题；函数式编程，有利于测试，给参数看输出是否正确即可；
4. react tool可以看react组件之间的穿值和参数，数据的更改也是实时变化的；
5. 生命周期
  1. willMount-render-DidMount, 上述仅在mount的过程中被执行，之后改变的时候就不会执行了
  2. updation：更新的过程
    1. state
      1. shouldComponentUpdate：返回的是true或者false，可以用于阻止组件更新
        应用例子如下
        ```javascript
          shouldComponentUpdate(nextProps,nextState){
            if(this.props.yourAim === nextProps.yourAim){
              return false
            }
            return true
          }
        ```
      2. WillUpdate
      3. render
      4. DidUpdate
    2. props
      1. 最前面多了一个WillReceiveProps:当组件被创建之后且props发生改变的时候会执行；作用猜想，仅接受一次参数且不可被修改；
1. charles进行本地mock；使用map local的方式，
2. 动画相关
  1. 直接通过CSS的方式，代码如下;forwards表示保存下来最后一帧的情况
    ```css
      .show{
        opacity:1;
        transition: all 1s ease-in
      }
      .hide {
        animation: hide-item 2s ease-in forwards;
      }
      @keyframes hide-item{
        0%{
          opacity: 1;
          color:red;
        }
        50%{
          opacity: 0.5;
          color:red;
        }
        100%{
          opacity: 0;
          color:red;
        }
      }
    ```
  1. react-transition-group，使用JS的方式实现较复杂的动画；实现看官网，本身还是监控入场和出场两个方式；
    1. 使用CSSTransition和TransitionGroup两个组件进行动画和成组动画的实现； 
1. [Redux使用](http://huziketang.mangojuice.top/books/react/lesson34)
  1. ![工作流程图](https://s3.amazonaws.com/youthchina/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2019-03-13+20.53.40.png)
  1. 比喻上的说法：假设整体是一个图书馆，场景是借书。components是来借书的人，借书的时候就是action creator，然后告诉图书管理员(store)，图书管理员需要查阅小本本(reducer)来看是否能借或者说是否有action的东西，有的话就给components；
  2. reducer：包括数据结构和action，本身就是一个stateChanger,和store进行通信；注意里面的state改变依旧是react风格，事例代码如下
    ```javascript
      const defaultValue = {
        inputValue:'123'
      }

      export default (state = defaultValue, action) => {
        // 监控action的type来看数据操作
        switch(action.type){
          case 'change_input_value':
            return {...state, inputValue: action.inputValue}
          default:
            return state
        }
      }
    ```
  1. `store = createStore(reducer)`
  2. `store.dispatch`进行数据更改的提交
  3. `store.subscribe`订阅事件，这样每次数据更改后会自动执行相关函数
  4. 将所有的action都独立抽出去变成一个文件，这样拼写或者添加内容时候就能集中处理，因为变量的拼写错误是会包出来的；
  1. 使用方法如下：
    首先是提升变量阶段，将app外面包裹一层provider
    ```javascript
      const App = {
        <Provider store={store}>
          <App />
        </Provider>
      }
    ```
    链接state和store里面的变量
    ```javascript
      const mapStateToProps = (state) => {
        return {
          inputValue: state.inputValue
        }
      }
    ```
    链接方法和reducer里面的方法type
    ```javascript
      const mapDispatchToProps = (dispatch) => {
        return {
          handleClickChange: (value) => (
              dispatch({type:'HANDLE_CLICK_CHANGE',inputValue:value})
            )
        }
      }
    ```
    构建高阶组件
    ```javascript
      app = connect(mapStateToProps,mapDispatchToProps)(app)
    ```
  5. [redux-thunk](https://github.com/reduxjs/redux-thunk)  redux的中间件，使得action里面可以返回函数而不仅是对象，实例如下
    ```javascript
      const action = () => {
        return (dispatch) => {
          axios.get('list/json').then((res)=>{
            const data = res.data
            dispatch(initListAction(data))
          })
        }
      }
      store.dispatch(action)
    ```
    在store声明的时候要加入中间件使用，这样dispatch的时候，函数就会被执行；本身的优势一个是易于管理，另一个就是方便测试；
    [流程图如下](https://s3.amazonaws.com/youthchina/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7+2019-03-14+09.55.22.png)
  1. redux-saga
    1. 类似thunk，也是中间件，解决的是抽离异步的过程；
    2. [配置按照github上面的流程来](https://github.com/redux-saga/redux-saga)
    3. 内容放在sagas.js文件里面，使用的是generator函数，即使用yield实现中间件；代码实例如下
      ```javascript
        function* mySage(){
          yield takeEvery(YOUR_ACTION_TYPE, aimFunc);
        }
      ```
      这样对于特定的type，就会执行目标方法，通过yield实现，且aimFunc也是一个迭代函数 
    1. 同样的，异步获取的内容放在这个文件里面，另外使用的不是dispatch，而是通过自带的put方法
1. 项目相关
  1. 




