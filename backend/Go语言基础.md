## 基础内容

1. 变量

   1. 声明时候变量名字在前，类型在后；
   2. 声明一定要用；
   3. 有自动的类型推断；
   4. :=定义且赋值，但是不能用在函数外面，只能用var关键字去做；
   5. 外面声明是包变量，没有全局变量的说法；
   6. var()里面声明多变量可以省略点；
   7. Fmt.Println进行输出
   8. 有虚数，用i表示，虚数计算在cmplx库里面，
   9. 类型都是强制转换

2. 常量：

   1. const声明常量，赋值时候可以指定类型也可以不指定；
   2. 枚举使用iota关键字去做。类似excel里面的，给第一个附上公式后，成组声明的变量就会根据iota的递增去产生值
   3. nil表示空

3. 条件

   1. if里面可以赋值后使用分号隔开再判断。里面赋值的变量作用域就是if块
   2. switch里面不用自己去break，进入case后自己就break；里面可以没有表达式，写在case里面就行
   3. Panic执行会中断程序

4. 循环

   1. for里面三个部分都可以省略，都省略之后就是死循环；只留下结束条件表示退出循环的条件，替代了while
   2. 写死循环的方便是为了之后的channel之间的通信

5. 函数

   1. 可以自定义多返回值，不要乱用，一般用于返回错误；不想要的部分使用_接住
   2. 因为panic会中断程序，所以返回自定义的错误去看，使用fmt.Errorf
   3. 感觉函数里面的类型可以用站位符去理解，func(int, int) int，即两个输入都是整数，输出也是整数
   4. 有可变参数，没有默认参数；func(arg1, …int)这么去声明

6. 指针

   1. go函数都是值传递；可以通过指针配合，比如pa *int这种，将&a传进来，即a的地址放进来，就可以实现引用传递了；

   2. 使用cache也能实现引用传递；

   3. 指针声明如下

      ```go
      var a int = 3
      var p *int = &a 
      ```

   4. 交换通过`return b, a`这样的方式，因为是值传递；

7. 数组

   1. 使用的是[5]int的方式，后面接{}就是自己赋值，否则使用0补充
   2. 两个产生的就是多维度的数组 
   3. range使用遍历数组；
   4.  因为值传递的原因，传进去数组很难改变，且因为声明里面要求长度的问题，用起来费劲

8. 切片

   1. 即数组切出来部分。左闭右开
   2. 切片拿到的是引用地址，相当于是数组的视图。本身是没有值的
   3. 对于数组的操作要基于切片
   4. reSlice的时候，区间只要不超过基准的arr就可以
   5. cap和len看容量和长度
   6. 有多维切片