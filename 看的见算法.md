1. UI构建
   1. 抗锯齿，因为有像素点在，所以矩形会有变，抗锯齿的原理就是把多出的部分，利用颜色渐变，从白渐变到黑
   2. 双缓存技术：因为画布画完后投影到屏幕上，之后图形改变的时候，是先清空再画上去，所以屏幕会有闪烁；双缓存就是说再多一张画布，然后交替计算图形位置和投影到屏幕，这样就没有空白的过程
2. 随机模拟问题
   1. 100个人，每人100元，每次都随机给其他人1元，足够长时间后的状态是？利用计算机随机模拟可以看出状态是不固定的，不是大家趋于平均，实际上相当于1万元随机分给100个人然后挑一个状态出来
   2. 蒙特卡洛算法：二战时候解决随机模拟问题提出的算法代号是蒙特卡洛，因为本身是赌城，模拟方式和赌博差不多，也有拉斯维加斯算法
   3. 核心就是大量随机样本得到某一个系统计算的值；
   4. 三门问题：共有三扇门，一扇门后面有车，主持人打开一扇门且后面没有车，用户换门还是不换？
      1. 随机模拟过程，即模拟换门和不换门两个事件
      2. 猜对判断：随机有奖，随机用户猜，两个相同的时候换门就输，不同时候换门赢
      3. 结合上面的两个事件，完成模拟
      4. 问题在于主持人的选择不是等概率的
   5. 会不会中奖，即20%中奖，5个会不会？
      1. 显然不会，模拟的过程是多次的抽5次，记录每一个样本的true和false；
      2. 这个5是期望值，对于个人来讲是没有用的
3. 排序问题
   1. 选择排序，依次找最小值然后放到头部
      1. 可视化方面：已经排好的一个颜色，当前扫描的一个颜色，未扫描的一个颜色，当前循环中最小的一个颜色
      2. 三个变量，已经排好的索引，正在比较的索引，当前最小值的索引
      3. 变量一旦改变就setColor完成可视化
      4. 比较次数多但是交换次数少，如果是集装箱移动的话或者移动耗时，肯定还是选择排序最好
   2. 插入元素，从头到尾依次拿到新的元素和前面进行比较然后移动
      1. 因为每次交换都是借助了中间变量，所以可以先用变量接住i，然后每次比较都是原来的元素向后移动，直到找到i的位置
      2. 对于近乎有序的数组，本身可以是O(n)的算法
      3. 向前移动的过程中，二分查找不一定好，因为查到了还是要移动，不减少复杂度，而且对于近乎有序的数组反而麻烦
   3. 归并排序
      1. branch and conquer的思想要记住，递归的方法不要细想，但是记住方法的意义和输入输出
      2. 想看结构就多一个参数记录depth，然后打印的时候根据depth设置空格位数
      3. 优化方式：数据小的时候使用插入，左边已经比右边小的时候直接合并就好了
      4. merge的时候采用的是外排的策略
      5. 正常递归的方式是自顶向下的，也可以改成自下向上的
   4. 快速排序
      1. Partition然后左右都是递归执行，找到一个数，然后左边都是小于的右边都是大于的
      2. 大量元素都相同时候效率很差，对于单路来讲
      3. 双路解决了上面的问题，因为可以停在接近中间的位置
      4. 三路，即多一个和目标相等的区间，这样只要排小于和大于的区间，对于大量相同效果好
   5. 堆排
      1. 构建最大堆，将最后和头交换后再构建最大堆，递归完成
4. 迷宫求解问题
   1. 图的遍历，两个节点之间路程的问题，即上下左右四个递归过程，当坐标是出口则return true，当没有走过或者不是墙壁的时候则走，如果true就直接返回
   2. 加颜色就是每次go的时候设置true，然后for循环结束设置成false，表示遍历后也还是没有解，在最后return false表示没有解
   3. 借助栈实现非递归，
      1. 一个问题就是路径。因为之前是递归，所以for结束后是整个路径的结束，现在的for结束实际上是当前节点的四个方向结束，并不是路径的结束。
      2. 解决方案是，每次遍历节点的时候记录上一个点的位置，之后根据终点往上遍历就好
      3. 找到一条但不一定最短
   4. 广度优先是使用队列实现，对于无权图找到的是最短路径
   5. 可以看出，3和4的实现逻辑一样，所以可以将栈和队列都看看成是抽象队列，只是进和出的方式不同
5. 迷宫生成算法
   1. 单路径随机迷宫本质是一颗树，因为找到任意两点有路径的总和是树，所以问题在于生成一个随机树，和利用图生成最小生成树有些不同
   2. 生成算法：首先最外层找到两个点作为出入口，中间包围部分看成黑白相间的方块，目的是去掉若干个黑块使得出入口有一条路连接